import React, { useState, useCallback, useRef } from 'react';
import {
  Box,
  Container,
  Typography,
  Paper,
  Button,
  Grid,
  Card,
  CardContent,
  Chip,
  Stack,
  TextField,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  Alert,
} from '@mui/material';
import {
  GoogleMap,
  Marker,
  Autocomplete,
  useLoadScript,
} from '@react-google-maps/api';
import { DateTimePicker } from '@mui/x-date-pickers/DateTimePicker';
import { LocalizationProvider } from '@mui/x-date-pickers/LocalizationProvider';
import { AdapterDateFns } from '@mui/x-date-pickers/AdapterDateFns';
import { ko } from 'date-fns/locale';
import { YOUR_GOOGLE_MAPS_API_KEY } from '../_env/env.local';
import { useTravel } from '../context/TravelContext';

const libraries: ('places')[] = ['places'];

interface LocationData {
  lat: number;
  lng: number;
  placeName: string;
  placeAddress: string;
  placeId?: string;
}

interface RouteStep {
  travelMode: string;
  transitDetails?: {
    transitLine: {
      name: string;
      vehicle?: { type: string };
    };
  };
  staticDuration: string;
  distanceMeters: number;
}

interface Route {
  description: string;
  legs: Array<{
    steps: RouteStep[];
  }>;
  totalDuration: number;
  totalPrice: number;
}

const mapContainerStyle = {
  width: '100%',
  height: '400px',
  borderRadius: '8px',
  overflow: 'hidden',
};

const initialCenter = {
  lat: 37.5665,
  lng: 126.9780,
};

const IntegratedTravelPlanner: React.FC = () => {
  // Google Maps Î°úÎìú
  const { isLoaded, loadError } = useLoadScript({
    googleMapsApiKey: YOUR_GOOGLE_MAPS_API_KEY,
    libraries,
  });

  // ÏÉÅÌÉú Í¥ÄÎ¶¨
  const [origin, setOrigin] = useState<LocationData | null>(null);
  const [destination, setDestination] = useState<LocationData | null>(null);
  const [isSelectingOrigin, setIsSelectingOrigin] = useState(true);
  const [departureTime, setDepartureTime] = useState<Date | null>(null);
  const [transitPreference, setTransitPreference] = useState<'LESS_WALKING' | 'FEWER_TRANSFERS'>('LESS_WALKING');
  const [selectedModes, setSelectedModes] = useState<string[]>(['BUS', 'SUBWAY', 'TRAIN']);
  const [routes, setRoutes] = useState<Route[]>([]);
  const [loading, setLoading] = useState(false);
  const [mapRef, setMapRef] = useState<google.maps.Map | null>(null);
  const [selectedLocation, setSelectedLocation] = useState<google.maps.LatLngLiteral | null>(null);

  // Í≤ÄÏÉâ ÏûÖÎ†• ref
  const originAutocompleteRef = useRef<google.maps.places.Autocomplete | null>(null);
  const destinationAutocompleteRef = useRef<google.maps.places.Autocomplete | null>(null);

  // ÍµêÌÜµÏàòÎã® ÏòµÏÖò
  const transitModes = [
    { value: 'BUS', label: 'Î≤ÑÏä§', icon: 'üöå' },
    { value: 'SUBWAY', label: 'ÏßÄÌïòÏ≤†', icon: 'üöá' },
    { value: 'TRAIN', label: 'Í∏∞Ï∞®', icon: 'üöÑ' },
    { value: 'LIGHT_RAIL', label: 'Í≤ΩÏ†ÑÏ≤†', icon: 'üöä' },
  ];

  // Autocomplete Î°úÎìú Ìï∏Îì§Îü¨
  const onOriginAutocompleteLoad = (autocomplete: google.maps.places.Autocomplete) => {
    originAutocompleteRef.current = autocomplete;
    autocomplete.setComponentRestrictions({ country: 'kr' });
    autocomplete.setTypes(['establishment', 'geocode']);
  };

  const onDestinationAutocompleteLoad = (autocomplete: google.maps.places.Autocomplete) => {
    destinationAutocompleteRef.current = autocomplete;
    autocomplete.setComponentRestrictions({ country: 'kr' });
    autocomplete.setTypes(['establishment', 'geocode']);
  };

  // Ïû•ÏÜå ÏÑ†ÌÉù Ìï∏Îì§Îü¨
  const handlePlaceSelect = useCallback((isOrigin: boolean) => {
    const autocomplete = isOrigin ? originAutocompleteRef.current : destinationAutocompleteRef.current;
    const place = autocomplete?.getPlace();
    
    if (!place?.geometry?.location) return;

    const locationData: LocationData = {
      lat: place.geometry.location.lat(),
      lng: place.geometry.location.lng(),
      placeName: place.name || 'ÏÑ†ÌÉùÎêú Ïû•ÏÜå',
      placeAddress: place.formatted_address || 'Ï£ºÏÜå Ï†ïÎ≥¥ ÏóÜÏùå',
      placeId: place.place_id,
    };

    if (isOrigin) {
      setOrigin(locationData);
      setIsSelectingOrigin(false); // Ï∂úÎ∞úÏßÄ ÏÑ†ÌÉù ÌõÑ ÎèÑÏ∞©ÏßÄ ÏÑ†ÌÉù Î™®ÎìúÎ°ú
    } else {
      setDestination(locationData);
    }

    // ÏßÄÎèÑ Ïù¥Îèô
    if (place.geometry.viewport) {
      mapRef?.fitBounds(place.geometry.viewport);
    } else {
      mapRef?.panTo({ lat: locationData.lat, lng: locationData.lng });
      mapRef?.setZoom(15);
    }

    setSelectedLocation({ lat: locationData.lat, lng: locationData.lng });
  }, [mapRef]);

  // ÏßÄÎèÑ ÌÅ¥Î¶≠ Ìï∏Îì§Îü¨
  const handleMapClick = useCallback((e: google.maps.MapMouseEvent) => {
    if (!e.latLng) return;

    const lat = e.latLng.lat();
    const lng = e.latLng.lng();
    const location = { lat, lng };

    setSelectedLocation(location);

    // GeocodingÏùÑ ÌÜµÌï¥ Ï£ºÏÜå Ï†ïÎ≥¥ Í∞ÄÏ†∏Ïò§Í∏∞
    if (mapRef) {
      const geocoder = new google.maps.Geocoder();
      geocoder.geocode({ location }, (results, status) => {
        if (status === 'OK' && results?.[0]) {
          const locationData: LocationData = {
            lat,
            lng,
            placeName: results[0].formatted_address.split(',')[0] || 'ÏÑ†ÌÉùÎêú ÏúÑÏπò',
            placeAddress: results[0].formatted_address,
          };

          if (isSelectingOrigin) {
            setOrigin(locationData);
            setIsSelectingOrigin(false);
          } else {
            setDestination(locationData);
          }
        }
      });
    }
  }, [mapRef, isSelectingOrigin]);

  // POI ÌÅ¥Î¶≠ Ìï∏Îì§Îü¨
  const handlePOIClick = useCallback((placeId: string, latLng: google.maps.LatLng) => {
    if (!mapRef) return;

    const service = new google.maps.places.PlacesService(mapRef);
    service.getDetails(
      {
        placeId: placeId,
        fields: ['name', 'formatted_address', 'geometry', 'place_id']
      },
      (place, status) => {
        if (status === google.maps.places.PlacesServiceStatus.OK && place) {
          const locationData: LocationData = {
            lat: latLng.lat(),
            lng: latLng.lng(),
            placeName: place.name || 'ÏÑ†ÌÉùÎêú Ïû•ÏÜå',
            placeAddress: place.formatted_address || 'Ï£ºÏÜå Ï†ïÎ≥¥ ÏóÜÏùå',
            placeId: place.place_id,
          };

          if (isSelectingOrigin) {
            setOrigin(locationData);
            setIsSelectingOrigin(false);
          } else {
            setDestination(locationData);
          }

          setSelectedLocation({ lat: latLng.lat(), lng: latLng.lng() });
        }
      }
    );
  }, [mapRef, isSelectingOrigin]);

  // ÍµêÌÜµÏàòÎã® ÌÜ†Í∏Ä
  const handleModeToggle = (mode: string) => {
    setSelectedModes(prev => 
      prev.includes(mode) 
        ? prev.filter(m => m !== mode)
        : [...prev, mode]
    );
  };

  // ÏúÑÏπò Ï¥àÍ∏∞Ìôî
  const clearLocations = () => {
    setOrigin(null);
    setDestination(null);
    setSelectedLocation(null);
    setIsSelectingOrigin(true);
    setRoutes([]);
  };

  // Ï∂úÎ∞úÏßÄ/ÎèÑÏ∞©ÏßÄ ÍµêÏ≤¥
  const swapLocations = () => {
    const temp = origin;
    setOrigin(destination);
    setDestination(temp);
    // ÌòÑÏû¨ ÏÑ†ÌÉù ÏúÑÏπòÎèÑ ÏóÖÎç∞Ïù¥Ìä∏
    if (destination) {
      setSelectedLocation({ lat: destination.lat, lng: destination.lng });
    }
  };

  // ÏÑ†ÌÉù Î™®Îìú Î≥ÄÍ≤Ω
  const setSelectionMode = (isOrigin: boolean) => {
    setIsSelectingOrigin(isOrigin);
  };

  // Í≤ΩÎ°ú Í≤ÄÏÉâ
  const searchRoutes = async () => {
    if (!origin || !destination) {
      alert('Ï∂úÎ∞úÏßÄÏôÄ ÎèÑÏ∞©ÏßÄÎ•º Î™®Îëê ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî.');
      return;
    }

    setLoading(true);
    try {
      // Ïã§Ï†úÎ°úÎäî Google Routes API ÎòêÎäî ÎåÄÏ§ëÍµêÌÜµ API Ìò∏Ï∂ú
      // Ïó¨Í∏∞ÏÑúÎäî Î™©ÏóÖ Îç∞Ïù¥ÌÑ∞Î°ú ÎåÄÏ≤¥
      const mockRoutes: Route[] = [
        {
          description: `${origin.placeName} ‚Üí ${destination.placeName}`,
          legs: [{
            steps: [
              {
                travelMode: 'TRANSIT',
                transitDetails: {
                  transitLine: {
                    name: '2Ìò∏ÏÑ†',
                    vehicle: { type: 'SUBWAY' }
                  }
                },
                staticDuration: '25Î∂Ñ',
                distanceMeters: 8500
              },
              {
                travelMode: 'TRANSIT',
                transitDetails: {
                  transitLine: {
                    name: '472Î≤à',
                    vehicle: { type: 'BUS' }
                  }
                },
                staticDuration: '15Î∂Ñ',
                distanceMeters: 3200
              }
            ]
          }],
          totalDuration: 40,
          totalPrice: 2650
        },
        {
          description: `${origin.placeName} ‚Üí ${destination.placeName}`,
          legs: [{
            steps: [
              {
                travelMode: 'TRANSIT',
                transitDetails: {
                  transitLine: {
                    name: '153Î≤à',
                    vehicle: { type: 'BUS' }
                  }
                },
                staticDuration: '45Î∂Ñ',
                distanceMeters: 12800
              }
            ]
          }],
          totalDuration: 45,
          totalPrice: 2000
        },
        {
          description: `${origin.placeName} ‚Üí ${destination.placeName}`,
          legs: [{
            steps: [
              {
                travelMode: 'TRANSIT',
                transitDetails: {
                  transitLine: {
                    name: '9Ìò∏ÏÑ†',
                    vehicle: { type: 'SUBWAY' }
                  }
                },
                staticDuration: '35Î∂Ñ',
                distanceMeters: 11200
              }
            ]
          }],
          totalDuration: 35,
          totalPrice: 2150
        }
      ];

      // API Ìò∏Ï∂ú ÏãúÎÆ¨Î†àÏù¥ÏÖò
      setTimeout(() => {
        setRoutes(mockRoutes);
        setLoading(false);
      }, 1500);

    } catch (error) {
      console.error('Í≤ΩÎ°ú Í≤ÄÏÉâ Ïã§Ìå®:', error);
      setLoading(false);
    }
  };

  // ÏöîÍ∏à Í≥ÑÏÇ∞
  const calculatePrice = (distanceMeters: number, vehicleType?: string): number => {
    const distanceKm = distanceMeters / 1000;
    
    switch (vehicleType) {
      case 'BUS':
        return distanceKm < 10 ? 1500 : 2000;
      case 'SUBWAY':
        return distanceKm < 10 ? 1500 : 2150;
      case 'TRAIN':
        return Math.max(2000, Math.round(distanceKm * 150));
      default:
        return 1500;
    }
  };

  // Travel Context ÏÇ¨Ïö©
  const { routeData, setRouteData, addPlace } = useTravel();

  // Í≤ΩÎ°ú ÏÑ†ÌÉù Ìï∏Îì§Îü¨
  const handleRouteSelect = (route: Route) => {
    if (!origin || !destination) return;
    
    const newRouteData = {
      origin,
      destination,
      selectedRoute: {
        description: route.description,
        totalDuration: route.totalDuration,
        totalPrice: route.totalPrice,
        steps: route.legs[0]?.steps || []
      }
    };
    
    setRouteData(newRouteData);
    
    // ÏÑ†ÌÉùÎêú Ïû•ÏÜåÎì§ÏùÑ Ïó¨ÌñâÏßÄ Î™©Î°ùÏóê Ï∂îÍ∞Ä
    addPlace(origin);
    addPlace(destination);
    
    alert(`Í≤ΩÎ°úÍ∞Ä ÏÑ†ÌÉùÎêòÏóàÏäµÎãàÎã§!\nÏÜåÏöîÏãúÍ∞Ñ: ${route.totalDuration}Î∂Ñ\nÏöîÍ∏à: ${route.totalPrice.toLocaleString()}Ïõê\n\nÏù¥ Í≤ΩÎ°úÍ∞Ä Ïó¨Ìñâ Í≥ÑÌöçÏóê Ï†ÄÏû•ÎêòÏóàÏäµÎãàÎã§.`);
  };

  if (loadError) return <div>ÏßÄÎèÑÎ•º Î∂àÎü¨Ïò§Îäî Ï§ë Ïò§Î•ò Î∞úÏÉù</div>;
  if (!isLoaded) return <div>ÏßÄÎèÑÎ•º Î∂àÎü¨Ïò§Îäî Ï§ë...</div>;

  return (
    <LocalizationProvider dateAdapter={AdapterDateFns} adapterLocale={ko}>
      <Container maxWidth="xl" sx={{ py: 4 }}>
        <Typography variant="h4" component="h1" gutterBottom align="center" sx={{ mb: 4 }}>
          üöá Ïä§ÎßàÌä∏ Ïó¨Ìñâ ÍµêÌÜµÌé∏ ÏïàÎÇ¥
        </Typography>

        <Grid container spacing={3}>
          {/* ÏôºÏ™Ω: ÏßÄÎèÑ ÏòÅÏó≠ */}
          <Grid item xs={12} lg={8}>
            <Paper elevation={3} sx={{ p: 3 }}>
              <Typography variant="h6" gutterBottom>
                üìç ÏßÄÎèÑÏóêÏÑú Ïû•ÏÜå ÏÑ†ÌÉù
              </Typography>
              
              {/* ÌòÑÏû¨ ÏÑ†ÌÉù Î™®Îìú ÌëúÏãú */}
              <Alert 
                severity={isSelectingOrigin ? "info" : "success"} 
                sx={{ mb: 2 }}
              >
                {isSelectingOrigin 
                  ? "üîµ Ï∂úÎ∞úÏßÄÎ•º ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî. ÏßÄÎèÑÎ•º ÌÅ¥Î¶≠ÌïòÍ±∞ÎÇò Í≤ÄÏÉâÌïòÏÑ∏Ïöî."
                  : "üü¢ ÎèÑÏ∞©ÏßÄÎ•º ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî. ÏßÄÎèÑÎ•º ÌÅ¥Î¶≠ÌïòÍ±∞ÎÇò Í≤ÄÏÉâÌïòÏÑ∏Ïöî."
                }
              </Alert>

              {/* ÏßÄÎèÑ ÏúÑ Í≤ÄÏÉâ Î∞î */}
              <Box sx={{ mb: 2, display: 'flex', gap: 2, flexWrap: 'wrap', alignItems: 'center' }}>
                <Autocomplete onLoad={onOriginAutocompleteLoad} onPlaceChanged={() => handlePlaceSelect(true)}>
                  <TextField
                    placeholder="Ï∂úÎ∞úÏßÄ Í≤ÄÏÉâ..."
                    size="small"
                    sx={{ minWidth: 200 }}
                    InputProps={{
                      startAdornment: <span style={{ marginRight: 8 }}>üîµ</span>
                    }}
                  />
                </Autocomplete>
                
                <Autocomplete onLoad={onDestinationAutocompleteLoad} onPlaceChanged={() => handlePlaceSelect(false)}>
                  <TextField
                    placeholder="ÎèÑÏ∞©ÏßÄ Í≤ÄÏÉâ..."
                    size="small"
                    sx={{ minWidth: 200 }}
                    InputProps={{
                      startAdornment: <span style={{ marginRight: 8 }}>üü¢</span>
                    }}
                  />
                </Autocomplete>

                <Button 
                  variant="outlined" 
                  size="small"
                  onClick={swapLocations}
                  disabled={!origin || !destination}
                >
                  ‚ÜïÔ∏è ÍµêÏ≤¥
                </Button>
                
                <Button 
                  variant="outlined" 
                  size="small" 
                  onClick={clearLocations}
                >
                  üóëÔ∏è Ï¥àÍ∏∞Ìôî
                </Button>
              </Box>

              {/* ÏÑ†ÌÉù Î™®Îìú ÌÜ†Í∏Ä Î≤ÑÌäº */}
              <Box sx={{ mb: 2, display: 'flex', gap: 1 }}>
                <Button
                  variant={isSelectingOrigin ? "contained" : "outlined"}
                  size="small"
                  onClick={() => setSelectionMode(true)}
                  startIcon={<span>üîµ</span>}
                >
                  Ï∂úÎ∞úÏßÄ ÏÑ†ÌÉù
                </Button>
                <Button
                  variant={!isSelectingOrigin ? "contained" : "outlined"}
                  size="small"
                  onClick={() => setSelectionMode(false)}
                  startIcon={<span>üü¢</span>}
                >
                  ÎèÑÏ∞©ÏßÄ ÏÑ†ÌÉù
                </Button>
              </Box>

              {/* Google Map */}
              <GoogleMap
                mapContainerStyle={mapContainerStyle}
                center={selectedLocation || initialCenter}
                zoom={selectedLocation ? 15 : 12}
                onLoad={(map) => {
                  setMapRef(map);
                  map.addListener('click', (event: google.maps.MapMouseEvent & { placeId?: string }) => {
                    if (event.placeId) {
                      event.stop();
                      handlePOIClick(event.placeId, event.latLng as google.maps.LatLng);
                    } else {
                      handleMapClick(event);
                    }
                  });
                }}
                options={{
                  clickableIcons: true,
                  disableDefaultUI: false,
                  gestureHandling: 'cooperative',
                }}
              >
                {/* Ï∂úÎ∞úÏßÄ ÎßàÏª§ */}
                {origin && (
                  <Marker 
                    position={{ lat: origin.lat, lng: origin.lng }}
                    icon={{
                      url: 'data:image/svg+xml;charset=UTF-8,%3Csvg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="%234285f4"%3E%3Cpath d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7z"/%3E%3C/svg%3E',
                      scaledSize: new google.maps.Size(40, 40),
                    }}
                    title={`Ï∂úÎ∞úÏßÄ: ${origin.placeName}`}
                  />
                )}
                
                {/* ÎèÑÏ∞©ÏßÄ ÎßàÏª§ */}
                {destination && (
                  <Marker 
                    position={{ lat: destination.lat, lng: destination.lng }}
                    icon={{
                      url: 'data:image/svg+xml;charset=UTF-8,%3Csvg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="%2334a853"%3E%3Cpath d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7z"/%3E%3C/svg%3E',
                      scaledSize: new google.maps.Size(40, 40),
                    }}
                    title={`ÎèÑÏ∞©ÏßÄ: ${destination.placeName}`}
                  />
                )}
              </GoogleMap>

              {/* ÏÑ†ÌÉùÎêú ÏúÑÏπò Ï†ïÎ≥¥ */}
              <Box sx={{ mt: 2 }}>
                {origin && (
                  <Box sx={{ mb: 1, p: 2, bgcolor: 'primary.50', borderRadius: 1, border: '1px solid', borderColor: 'primary.200' }}>
                    <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start' }}>
                      <Box sx={{ flex: 1 }}>
                        <Typography variant="body2" color="primary">
                          <strong>üîµ Ï∂úÎ∞úÏßÄ:</strong> {origin.placeName}
                        </Typography>
                        <Typography variant="caption" color="text.secondary">
                          {origin.placeAddress}
                        </Typography>
                      </Box>
                      <Button
                        size="small"
                        variant="outlined"
                        onClick={() => addPlace(origin)}
                        sx={{ ml: 1, minWidth: 'auto' }}
                      >
                        ‚ûï Ïó¨ÌñâÏßÄ Ï∂îÍ∞Ä
                      </Button>
                    </Box>
                  </Box>
                )}
                
                {destination && (
                  <Box sx={{ p: 2, bgcolor: 'success.50', borderRadius: 1, border: '1px solid', borderColor: 'success.200' }}>
                    <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start' }}>
                      <Box sx={{ flex: 1 }}>
                        <Typography variant="body2" color="success.main">
                          <strong>üü¢ ÎèÑÏ∞©ÏßÄ:</strong> {destination.placeName}
                        </Typography>
                        <Typography variant="caption" color="text.secondary">
                          {destination.placeAddress}
                        </Typography>
                      </Box>
                      <Button
                        size="small"
                        variant="outlined"
                        color="success"
                        onClick={() => addPlace(destination)}
                        sx={{ ml: 1, minWidth: 'auto' }}
                      >
                        ‚ûï Ïó¨ÌñâÏßÄ Ï∂îÍ∞Ä
                      </Button>
                    </Box>
                  </Box>
                )}
              </Box>
            </Paper>
          </Grid>

          {/* Ïò§Î•∏Ï™Ω: ÍµêÌÜµÌé∏ Í≤ÄÏÉâ Î∞è Í≤∞Í≥º */}
          <Grid item xs={12} lg={4}>
            <Paper elevation={3} sx={{ p: 3, mb: 3 }}>
              <Typography variant="h6" gutterBottom>
                üöå ÍµêÌÜµÌé∏ ÏòµÏÖò
              </Typography>

              {/* ÍµêÌÜµÏàòÎã® ÏÑ†ÌÉù */}
              <Box sx={{ mb: 3 }}>
                <Typography variant="subtitle2" gutterBottom>
                  Ïù¥Ïö©Ìï† ÍµêÌÜµÏàòÎã®
                </Typography>
                <Stack direction="row" spacing={1} flexWrap="wrap" useFlexGap>
                  {transitModes.map((mode) => (
                    <Chip
                      key={mode.value}
                      label={`${mode.icon} ${mode.label}`}
                      clickable
                      color={selectedModes.includes(mode.value) ? 'primary' : 'default'}
                      onClick={() => handleModeToggle(mode.value)}
                      size="small"
                    />
                  ))}
                </Stack>
              </Box>

              {/* Ï∂úÎ∞ú ÏãúÍ∞Ñ */}
              <Box sx={{ mb: 3 }}>
                <DateTimePicker
                  label="Ï∂úÎ∞ú ÏãúÍ∞Ñ (ÏÑ†ÌÉùÏÇ¨Ìï≠)"
                  value={departureTime}
                  onChange={setDepartureTime}
                  slotProps={{ 
                    textField: { 
                      size: 'small', 
                      fullWidth: true 
                    } 
                  }}
                />
              </Box>

              {/* Í≤ΩÎ°ú ÏÑ†Ìò∏ÎèÑ */}
              <Box sx={{ mb: 3 }}>
                <FormControl size="small" fullWidth>
                  <InputLabel>Í≤ΩÎ°ú ÏÑ†Ìò∏ÎèÑ</InputLabel>
                  <Select
                    value={transitPreference}
                    label="Í≤ΩÎ°ú ÏÑ†Ìò∏ÎèÑ"
                    onChange={(e) => setTransitPreference(e.target.value as 'LESS_WALKING' | 'FEWER_TRANSFERS')}
                  >
                    <MenuItem value="LESS_WALKING">üëü Í±∑Í∏∞ Ï†ÅÍ≤å</MenuItem>
                    <MenuItem value="FEWER_TRANSFERS">üîÑ ÌôòÏäπ Ï†ÅÍ≤å</MenuItem>
                  </Select>
                </FormControl>
              </Box>

              {/* Í≤ÄÏÉâ Î≤ÑÌäº */}
              <Button
                variant="contained"
                size="large"
                onClick={searchRoutes}
                disabled={loading || !origin || !destination || selectedModes.length === 0}
                fullWidth
                sx={{ mb: 3 }}
              >
                {loading ? 'Í≤ÄÏÉâ Ï§ë...' : 'üîç ÍµêÌÜµÌé∏ Í≤ÄÏÉâ'}
              </Button>
            </Paper>

            {/* ÌòÑÏû¨ ÏÑ†ÌÉùÎêú Í≤ΩÎ°ú Ï†ïÎ≥¥ */}
            {routeData && (
              <Paper elevation={3} sx={{ p: 3, mb: 3, bgcolor: 'success.50', border: '1px solid', borderColor: 'success.main' }}>
                <Typography variant="h6" gutterBottom color="success.dark">
                  ‚úÖ ÏÑ†ÌÉùÎêú Í≤ΩÎ°ú
                </Typography>
                <Typography variant="body2" sx={{ mb: 1 }}>
                  <strong>{routeData.origin.placeName}</strong> ‚Üí <strong>{routeData.destination.placeName}</strong>
                </Typography>
                <Typography variant="body2" color="text.secondary" sx={{ mb: 1 }}>
                  ÏÜåÏöîÏãúÍ∞Ñ: {routeData.selectedRoute?.totalDuration}Î∂Ñ | ÏöîÍ∏à: {routeData.selectedRoute?.totalPrice.toLocaleString()}Ïõê
                </Typography>
                <Button 
                  size="small" 
                  onClick={() => setRouteData(null)}
                  sx={{ mt: 1 }}
                >
                  üóëÔ∏è ÏÑ†ÌÉù Ìï¥Ï†ú
                </Button>
              </Paper>
            )}

            {/* Í≤ÄÏÉâ Í≤∞Í≥º */}
            {routes.length > 0 && (
              <Paper elevation={3} sx={{ p: 3 }}>
                <Typography variant="h6" gutterBottom>
                  üöá Ï∂îÏ≤ú Í≤ΩÎ°ú ({routes.length}Í∞ú)
                </Typography>
                
                {routes.map((route, index) => (
                  <Card key={index} sx={{ mb: 2 }} variant="outlined">
                    <CardContent>
                      <Typography variant="subtitle1" gutterBottom>
                        Í≤ΩÎ°ú {index + 1}
                      </Typography>
                      
                      {route.legs[0]?.steps.map((step, stepIndex) => (
                        <Box key={stepIndex} sx={{ mb: 1 }}>
                          <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, flexWrap: 'wrap' }}>
                            <span>
                              {step.transitDetails?.transitLine.vehicle?.type === 'BUS' ? 'üöå' :
                                step.transitDetails?.transitLine.vehicle?.type === 'SUBWAY' ? 'üöá' :
                                step.transitDetails?.transitLine.vehicle?.type === 'TRAIN' ? 'üöÑ' : 'üöä'}
                            </span>
                            <Typography variant="body2">
                              <strong>{step.transitDetails?.transitLine.name}</strong>
                            </Typography>
                            <Chip 
                              label={step.staticDuration} 
                              size="small" 
                              color="primary" 
                              variant="outlined"
                            />
                            <Chip 
                              label={`${calculatePrice(step.distanceMeters, step.transitDetails?.transitLine.vehicle?.type)}Ïõê`}
                              size="small" 
                              color="success" 
                              variant="outlined"
                            />
                          </Box>
                        </Box>
                      ))}
                      
                      <Box sx={{ mt: 2, pt: 2, borderTop: '1px solid #eee' }}>
                        <Typography variant="body2" color="text.secondary">
                          Ï¥ù ÏÜåÏöîÏãúÍ∞Ñ: {route.totalDuration}Î∂Ñ
                        </Typography>
                        <Typography variant="body2" color="text.secondary">
                          Ï¥ù ÏöîÍ∏à: {route.totalPrice.toLocaleString()}Ïõê
                        </Typography>
                      </Box>
                      
                      <Button 
                        variant="contained" 
                        size="small" 
                        fullWidth 
                        sx={{ mt: 2 }}
                        onClick={() => handleRouteSelect(route)}
                      >
                        ‚úÖ Ïù¥ Í≤ΩÎ°ú ÏÑ†ÌÉù
                      </Button>
                    </CardContent>
                  </Card>
                ))}
              </Paper>
            )}

            {/* Î°úÎî© ÏÉÅÌÉú */}
            {loading && (
              <Paper elevation={3} sx={{ p: 3, textAlign: 'center' }}>
                <Typography variant="body1">
                  üîç ÏµúÏ†ÅÏùò Í≤ΩÎ°úÎ•º Ï∞æÍ≥† ÏûàÏäµÎãàÎã§...
                </Typography>
              </Paper>
            )}
          </Grid>
        </Grid>
      </Container>
    </LocalizationProvider>
  );
};

export default IntegratedTravelPlanner;